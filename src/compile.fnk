{readFileSync, writeFileSync, mkdirSync, existsSync} = import 'fs'
{dirname} = import 'path'

{parse} = import '@fink/larix'
{generate} = import '@fink/loxia'

convert_source_map = import 'convert-source-map'

{get_files} = import './files'
{logger} = import './logging'

{warn} = logger()


transform = fn source, filename:
  [ast, {errors}] = parse source, filename

  match errors:
    {length: 0}:
      generate ast, filename, source
    else:
      {errors}


compile = fn filename:
  buff = readFileSync filename
  source = buff.toString 'utf8'
  transform source, filename


output_to_dir = fn {code, src_path, out_path, rel_path}:
  dir = dirname out_path
  match false:
    existsSync dir:
      mkdirSync dir, {recursive: true}
      warn 'created ${dir}'

  writeFileSync out_path, code

  warn 'compiled ${src_path} -> ${out_path}'
  out_path


output_code = fn {stdout}, item:
  match item.out_path:
    null: stdout.write '${item.code}\n'
    else: output_to_dir item
  item

add_source_map_inline = fn {code, map: source_map}:
  converter = convert_source_map.fromObject source_map
  comment = converter.toComment()
  '${code}\n${comment}'


compile_all = fn proc, src, out_dir=null, ignore=null, source_maps=false:
  files = get_files src, out_dir, ignore

  pipe files:
    map {src_path, out_path, rel_path}:
      compiled = compile src_path

      match compiled:
        {errors: {length: ? > 0}}:
          {errors} = compiled
          {src_path, out_path, rel_path, errors}

        else:
          code = match source_maps:
            'inline': add_source_map_inline compiled
            else: compiled.code

          item = {src_path, out_path, rel_path, code}
          output_code proc, item

